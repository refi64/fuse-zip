#!/bin/sh
############################################################################
##  Copyright (C) 2010-2021 by Alexander Galanin                          ##
##  al@galanin.nnov.ru                                                    ##
##  http://galanin.nnov.ru/~al                                            ##
##                                                                        ##
##  This program is free software: you can redistribute it and/or modify  ##
##  it under the terms of the GNU General Public License as published by  ##
##  the Free Software Foundation, either version 3 of the License, or     ##
##  (at your option) any later version.                                   ##
##                                                                        ##
##  This program is distributed in the hope that it will be useful,       ##
##  but WITHOUT ANY WARRANTY; without even the implied warranty of        ##
##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         ##
##  GNU General Public License for more details.                          ##
##                                                                        ##
##  You should have received a copy of the GNU General Public License     ##
##  along with this program.  If not, see <https://www.gnu.org/licenses/>.##
############################################################################
# \
exec tclsh "$0" "$@"

package require Tcl 8.6
package require BLT
package require Tclx
package require cmdline
package require struct::set
package require control

::control::control assert enabled true

namespace eval ::fusezip::test {
    namespace import ::control::assert

    variable binary [file join [file dirname [info script]] ../../fuse-zip]
    variable tmpdir [ exec mktemp -d "/tmp/fuse-zip-tests-[ pid ].XXXXXXXXXX" ]
    # two minutes
    variable timeout [ expr {1000 * 60 * 2} ]

    variable valgrind false
    variable listTests false
    variable enabledConditions {}

    variable status {}
    variable error {}
    variable output {}
    variable initializationState {}

    variable numPassed 0
    variable numFailed 0
    variable numSkipped 0
    variable failed {}

    # parseArgs --
    #
    #   Parse commnd-line arguments.
    #   Keys -list, -valgrind, -listfailed are recognized, all other parameters
    #   added to match list to filter tests.

    proc parseArgs {} {
        variable matchList
        variable enabledConditions
        upvar #0 argv argv

        set options {
            {list       "List tests and exit"}
            {valgrind   "Run tests under valgrind and check memory errors"}
            {sudo       "Enable tests that require sudo"}
            {-help      "Print this message"}
        }

        if {[ catch {
            array set p [ ::cmdline::getKnownOptions argv $options ]
        } msg ]} {
            puts stderr $msg
            exit 1
        }
        if {$p(-help)} {
            puts [ ::cmdline::usage $options ]
            exit 1
        }
        variable listTests $p(list)
        variable valgrind $p(valgrind)
        if {$p(sudo)} {
            lappend enabledConditions sudo
        }
        if {[llength [auto_execok pkzipc]] != 0} {
            lappend enabledConditions pkzip
        }

        if {[ llength $argv ] != 0} {
            set matchList $argv
        } else {
            set matchList *
        }
    }

    # wrapIfNeeded --
    #
    #   Wrap executable using valgrind if valgrinding is enabled (environment
    #   variable VALGRIND is set to 1).
    #   If env. variable VALGRIND_ARGS is present, it recognized as
    #   space-separated list of additional arguments for valgrind (for example,
    #   VALGRIND_ARGS="--gen-suppressions=all").

    proc wrapIfNeeded {command} {
        variable valgrind

        if {$valgrind} {
            set additional {}
            if {[ info exists ::env(VALGRIND_ARGS) ]} {
                set additional [ split $::env(VALGRIND_ARGS) ]
            }
            set res [ list valgrind -q --leak-check=full --track-origins=yes --error-exitcode=33 --suppressions=valgrind.supp {*}$additional ]
        } else {
            set res {}
        }
        lappend res $command
        return $res
    }

    # fstest --
    #
    #   Execute 'script', check return code and clean up.
    #   If script exited with error, error information and filesystem stderr
    #   printed.
    #   Test is executed only if id matches at least one pattern in matchList.
    #
    # Arguments:
    #   id          Test ID
    #   description Test Description
    #   script      Test body
    #   conditions  (optional) conditions to execute test

    proc fstest {id description script {conditions {}}} {
        variable mounted false
        variable error
        variable numPassed
        variable numFailed
        variable numSkipped
        variable tmpdir
        variable mountdir
        variable matchList
        variable failed
        variable enabledConditions
        upvar fname fname
        set fname {}

        set do false
        foreach match $matchList {
            if {[ string match $match $id ]} {
                set do true
                break
            }
        }
        foreach cond $conditions {
            if {$cond ni $enabledConditions} {
                set do false
            }
        }
        if {!$do} {
            incr numSkipped
            return
        }

        file mkdir $tmpdir
        set mountdir "[ file join $tmpdir mountPoint ]-$id"
        file mkdir $mountdir
        set pwd [pwd]
        set code [ catch {
            if {[ catch {
                uplevel $script
            } err opts ]} {
                if {[ catch {
                    umount
                } err2 opts2 ]} {
                    dict set opts2 -cause $opts
                    return -options $opts2
                }
                return -options $opts
            }
        } ret opts ]
        switch $code {
            0 {
                # TCL_OK
                incr numPassed
            }
            1 {
                # TCL_ERROR
                forceumount
                puts "\nTest `$id' ($description) failed."
                puts ""
                puts "Error: [ dict get $opts -errorinfo ]"
                puts "Error code [ dict get $opts -code ], errorcode [ dict get $opts -errorcode ]"
                if {[ dict exists $opts -cause ]} {
                    set opts [ dict get $opts -cause ]
                    puts "Caused by:"
                    puts "Error: [ dict get $opts -errorinfo ]"
                    puts "Error code [ dict get $opts -code ], errorcode [ dict get $opts -errorcode ]"
                }
                puts ""
                puts "Filesystem output: [ join $error \n ]"

                lappend failed $id
                incr numFailed
            }
            default {
                puts "\nTest `$id' ($description) returned incorrect code($code): [ lindex {OK ERROR RETURN BREAK CONTINUE} $code ]"
                incr numSkipped
            }
        }
        cd $pwd
        if {"sudo" in $conditions} {
            exec sudo chmod -R u+w $tmpdir
            exec sudo rm -rf $tmpdir
        } else {
            exec chmod -R u+w $tmpdir
            exec rm -rf $tmpdir
        }
    }

    # mount --
    #
    #   Mount fuse-zip on archive fname to mountdir.
    #   Filesystem process started in background but without detaching from
    #   terminal and with debug mode enabled. Messages sent to stderr are
    #   parsed to determine finish of file system initialization process.
    #
    # Variables:
    #   fname   Archive file name (from caller context)
    # Arguments:
    #   args    Additional file system arguments

    proc mount {args} {
        upvar fname fname
        variable binary
        variable mountdir
        variable tmpdir
        variable stopped
        variable output
        variable error
        variable mounted
        variable initializationState

        if {$fname eq ""} {
            set fname "$tmpdir/test.zip"
        }

        set ns [ namespace current ]
        set ${ns}::status {STARTED}
        # if file system stopped in abnormal way, variable
        # 'initializationState' is set to exit from vwait block.
        set cmd [ list ${ns}::status {write unset} \
            [ list apply [ list {args} {
                variable initializationState exited
            } $ns ] ] \
        ]
        trace add variable {*}$cmd
        set output {}
        set error {}
        blt::bgexec ${ns}::status \
            -output ${ns}::output \
            -onerror ${ns}::processError \
            -linebuffered true \
            {*}[ wrapIfNeeded $binary ] {*}$args -d $fname $mountdir &

        vwait ${ns}::initializationState
        trace remove variable {*}$cmd
        if {$initializationState eq "exited"} {
            error "Filesystem not mounted (status=[ set ${ns}::status ])" {} NOTMOUNTED
        }
        set mounted true
    }

    # processError --
    #
    #   Process each line of stderr of called file system.
    #   Each line is appended to 'error' list to accumulate full output.
    #   If first message successfully went from filesystem, it assumed as
    #   mounted and listeners are notified by setting variable
    #   'initializationState'.
    #
    # Arguments:
    #   data    Line to process

    proc processError {data} {
        variable initializationState
        variable error

        set data [string trim $data]
        if {[ regexp {^INIT\M} $data ]} {
            set initializationState success
        }
        lappend error $data
    }

    # umount --
    #
    #   Unmount filesystem.
    #   Firstly try to umount FS in a standard way via fusermount -uz.
    #   If file system is not unmounted in a specified timeout, kill filesystem
    #   process and unmount in the hard way (fusermount -uz).
    #   If file system is already unmounted. do nothing.

    proc umount {} {
        variable mounted
        variable mountdir
        variable status
        variable timeout
        variable output
        variable error
        variable valgrind

        if {!$mounted} {
            return
        }

        set ns [ namespace current ]
        set statusVar ${ns}::status
        if {$status ne ""} {
            # not yet stopped
            if {[ catch {
                exec fusermount -uz $mountdir
            } err opts ]} {
                puts "Fusermount error: $err"
            }
            set afterId [ after $timeout [ list set $statusVar KILLED ] ]
            vwait $statusVar
            after cancel $afterId
        }
        lassign $status state pid code msg
        set status {}
        set mounted false
        if {$state eq "KILLED"} {
            catch {exec fusermount -uz $mountdir}
            error "Filesystem unmounting timed out"
        } else {
            if {$code != 0} {
                error "Filesystem returned error (code=$code)"
            }
            if {$output ne ""} {
                error "Unexpected output from filesystem: $output"
            }
        }
    }

    # forceumount --
    #
    #   Force kill filesystem process and free mountpoint

    proc forceumount {} {
        variable mountdir
        variable status

        catch {exec fusermount -u $mountdir}
        set [ namespace current ]::status FORCE-KILLED
        catch {exec fusermount -uz $mountdir}
    }

    # create --
    #
    #   Create specified list of files and directories in specified directory
    #   (relative to tmpdir).
    #
    # Arguments:
    #   dir     Destination directory
    #   files   List of files and directories to add
    #           Format of item:
    #           <filename> <content
    #           or
    #           <dirname>/

    proc createContent {dir files} {
        variable tmpdir

        file delete -force $tmpdir/$dir
        file mkdir $tmpdir/$dir

        set pos 0
        while {$pos < [ llength $files ]} {
            set name [ lindex $files $pos ]
            incr pos
            if {[ string index $name end ] == "/"} {
                file mkdir $tmpdir/$dir/$name
            } else {
                makeFile [ lindex $files $pos ] $dir/$name
                incr pos
            }
        }
    }

    # create --
    #
    #   Create archive for tests containing specified list of files and
    #   directories and set it name to variable fname in caller context.
    #
    # Arguments:
    #   files   List of files (as for createContent command)

    proc create {files} {
        variable tmpdir
        upvar fname fname

        set container [file join $tmpdir container]
        file delete -force $container
        file mkdir $container
        set fname $container/test.zip

        createContent archiveSource $files
        set pwd [ pwd ]
        cd $tmpdir/archiveSource
        if {[ catch {
            exec zip -r $fname {*}[ glob * ]
        } err opts ]} {
            cd $pwd
            return -options $opts
        }
        cd $pwd
    }

    # use --
    #
    #   Use specified file as input archive for test. Copy it into a temporary dir.
    #
    # Arguments:
    #   path path to archive
    proc use {path} {
        variable tmpdir
        upvar fname fname

        set container [file join $tmpdir container]
        file delete -force $container
        file mkdir $container
        set fname $container/test.zip
        file copy $path $fname
    }

    # unzip --
    #
    #   Extract file to temporary dir
    proc unzip {} {
        upvar fname fname
        variable tmpdir

        exec unzip -t $fname

        file delete -force $tmpdir/extract
        file mkdir $tmpdir/extract
        exec unzip -nd $tmpdir/extract $fname
    }

    # check --
    #
    #   Check archive integrity by using 'unzip -t' command.
    #   Check file content with expected.
    #   If any problem detected, error is thrown.
    #
    # Arguments:
    #   files   List of files (as for createContent command)

    proc check {files} {
        upvar fname fname
        variable tmpdir

        exec unzip -t $fname

        createContent expectedResult $files
        file delete -force $tmpdir/testResult
        file mkdir $tmpdir/testResult
        exec unzip -nd $tmpdir/testResult $fname
        exec diff -ura $tmpdir/testResult $tmpdir/expectedResult
    }

    # stripValgrindOutput --
    #
    #   Strip valgrind's output from data. If valgrinding is not enabled,
    #   return data as is.

    proc stripValgrindOutput {data} {
        set res {}
        foreach line [ split $data "\n" ] {
            if {![ regexp {^==\d+== } $line ]} {
                lappend res $line
            }
        }
        return [ join $res "\n" ]
    }

    # makeFile --
    #
    #   Version of tclTest::makeFile that does not creates newline at the end
    #   of file.

    proc makeFile {contents name {directory {}}} {
        variable tmpdir

        if {$directory eq ""} {
            set fname $tmpdir/$name
        } else {
            set fname $directory/$name
        }
        file mkdir [ file dirname $fname ]
        set f [ open $fname w ]
        puts -nonewline $f $contents
        close $f
    }

    # finalize --
    #
    #   Clean up temporary files, print statistics and exit.

    proc finalize {} {
        variable numPassed
        variable numFailed
        variable numSkipped
        variable tmpdir
        variable listTests
        variable failed

        forceumount
        catch {exec chmod -R a+w $tmpdir}
        file delete -force $tmpdir

        if {!$listTests} {
            if {[ llength $failed ] > 0} {
                puts "Failed tests: [ join $failed ]"
            }
            puts [ format {Total: %3d   Passed: %3d   Failed: %3d   Skipped %3d} \
                [ expr {$numPassed + $numFailed + $numSkipped} ] \
                $numPassed $numFailed $numSkipped \
            ]
            if {$numFailed != 0} {
                exit 1
            } else {
                exit 0
            }
        } else {
            exit 0
        }
    }

    # getPreciseTimes --
    #
    #   get high-precision time stamps of a file
    #
    # Arguments:
    #   fname   file name
    #
    # Return value:
    #   list of mtime and atime
    proc getPreciseTimes {fname} {
        foreach line [split [exec /usr/bin/env LC_ALL=C TZ=UTC stat $fname] \n] {
            if {[regexp -nocase {^([a-z]+): (.+)$} $line _ key value]} {
                switch $key {
                    Access {
                        set atime $value
                    }
                    Modify {
                        set mtime $value
                    }
                }
            }
        }
        return [list $mtime $atime]
    }

    # getExtendedAttributes --
    #
    #   get user.* extended attributes as dict
    #
    # Arguments:
    #   fname   file name
    proc getExtendedAttributes {fname} {
        set res {}
        foreach line [split [exec getfattr -d -e hex $fname 2> /dev/null] \n] {
            if {[regexp {^(user\.[a-zA-Z0-9_]+)=0x(.*)} $line _ key value]} {
                set value [encoding convertfrom utf-8 [binary decode hex $value]]
                dict set res $key $value
            }
        }
        return $res
    }

    # getZipComments --
    #
    #   get archive and file comments uzing unzip
    #
    # Arguments:
    #   fname   file name
    proc getZipComments {fname} {
        set res {}
        set name ""
        set comment {}
        set header 0
        foreach line [split [exec unzip -l $fname] \n] {
            if {$header == 0} {
                switch -regexp $line {
                    {^Archive: } {}
                    {^\s+Length\s+Date\s+Time\s+Name$} {
                        set header 1
                    }
                    default {
                        lappend comment $line
                    }
                }
            } elseif {$header == 1} {
                if {![regexp {^-+\s+-+\s+-+\s+-+$} $line]} {
                    error "bad delimiter format: `$line'"
                }
                set header 2
            } else {
                switch -regexp -matchvar match $line {
                    {^\s*[0-9]+\s+\d\d\d\d-\d\d-\d\d \d\d:\d\d\s+(.*)} {
                        if {[llength $comment] || $name eq ""} {
                            dict set res $name [join $comment \n]
                        }
                        lassign $match _ name
                        set comment {}
                    }
                    {^-+\s+-+$} {
                        if {[llength $comment] || $name eq ""} {
                            dict set res $name [join $comment \n]
                        }
                        break
                    }
                    default {
                        lappend comment $line
                    }
                }
            }
        }
        return $res
    }

    proc getZipItemInfo {fname itemname} {
        set res {
            unix_perms  unknown
            dos_perms   unknown
            comp_size   -1
            orig_size   -1
            method      unknown
        }
        foreach line [split [exec zipinfo -v $fname $itemname] \n] {
            switch -regex -matchvar match $line {
                {^ *compression method: *([a-z0-9]+)( \(.*\))?$} {
                    lassign $match _ method
                    dict set res method $method
                }
                {^ *compressed size: *([0-9]+) bytes$} {
                    lassign $match _ size
                    dict set res comp_size $size
                }
                {^ *uncompressed size: *([0-9]+) bytes$} {
                    lassign $match _ size
                    dict set res orig_size $size
                }
                {^ *Unix file attributes \(([0-7]{6,6}) octal\):} {
                    lassign $match _ attr
                    dict set res unix_perms $attr
                }
                {^ *MS-DOS file attributes \(([0-9a-fA-F]{2,2}) hex\):} {
                    lassign $match _ attr
                    dict set res dos_perms $attr
                }
            }
        }
        return $res
    }

    proc pkzipExtract {{sudo {}}} {
        upvar fname fname
        variable tmpdir

        file delete -force $tmpdir/extract
        file mkdir $tmpdir/extract
        set pwd [pwd]
        if {$sudo eq "sudo"} {
            set prefix sudo
        } else {
            set prefix {}
        }
        try {
            cd $tmpdir/extract
            exec {*}$prefix pkzipc -extract -filetype=all -permission $fname
        } on error {err opts} {
            exec {*}$prefix rm -rf $tmpdir/extract
            return -options $opts $err
        } finally {
            cd $pwd
        }
    }

    proc eassert {arg1 oper arg2 {text ""}} {
        set res [expr "\$arg1 $oper \$arg2"]
        if {$res} {
            return
        }
        if {$text eq ""} {
            set text "assertion failed"
        }
        error "$text: $arg1 $oper $arg2"
    }

    ############################################################
    # INITIALIZATION
    ############################################################

    parseArgs

    signal trap {HUP INT TERM} "puts stderr Interrupt; ::[ namespace current ]::finalize"

    if {$listTests} {
        # Stub for fstest that only prints test IDs and descriptions

        proc fstest {id description script} {
            puts [ format "%-40s %s" $id $description ]
        }
    }

    ############################################################
    # TESTS
    ############################################################

    fstest usage {Usage test} {
        lassign [ pipe ] r w
        if {![ catch {exec -ignorestderr {*}[ wrapIfNeeded $binary ] 2>@ $w} res opts ]} {
            close $w
            close $r
            error "Error code should be non-zero!"
        }
        close $w
        set data [ string trim [ read $r ] ]
        close $r
        if {![ regexp {^usage: fuse-zip } [ stripValgrindOutput $data ] ]} {
            error "Usage info expected, but `$data' given"
        }
    }

    fstest version {Version test} {
        lassign [ pipe ] r w
        if {![ catch {exec -ignorestderr {*}[ wrapIfNeeded $binary ] -V 2>@ $w} res opts ]} {
            close $w
            close $r
            error "Error code should be non-zero!"
        }
        close $w
        set data [ string trim [ read $r ] ]
        close $r
        if {![ regexp {^(.*?version.*?\d+\.\d+\n)+} \
                "[ stripValgrindOutput $data ]\n" ]} {
            error "Version info expected, but '$data' returned"
        }
    }

    fstest bad-mountpoint {Bad mountpoint} {
        file delete -force $mountdir
        if {![ catch {mount} err opts ] ||
                [ dict get $opts -errorcode ] ne "NOTMOUNTED"} {
            error "Mount error is expected"
        } else {
            set msg [ stripValgrindOutput [ join $error \n ] ]
            if {![ regexp {^fuse: bad mount point} $msg ]} {
                error "Invalid error message: $msg"
            }
        }
    }

    fstest bad-archive-crc {Bad archive} {
        use data/bad-archive.zip
        mount
        if {![catch {open $mountdir/bash.txt r} err opts]} {
            error "File read error is expected"
        } else {
            set code [dict get $opts -errorcode]
            assert {[lrange $code 0 1] == {POSIX EIO}}
        }
        umount
    }

    fstest mount-umount {Mount and unmount nonexistent file} {
        set fname $tmpdir/nonexistent.zip
        mount
        umount
        if {[ file exist $fname ]} {
            error "Archive should not exist!"
        }
    }

    fstest nonexistent-readonly {Trying to open nonexistent file in read-only mode (#52)} {
        set fname $tmpdir/nonexistent.zip
        if {![catch {mount -r} err opts] ||
                [dict get $opts -errorcode] ne "NOTMOUNTED"} {
            error "Mount error is expected"
        } else {
            set msg [stripValgrindOutput [join $error \n]]
            if {![regexp {^fuse-zip: cannot open ZIP archive} $msg]} {
                error "Invalid error message: $msg"
            }
        }
        umount
        if {[file exist $fname]} {
            error "Archive should not exist!"
        }
    }

    fstest 65536-files {Check that file system correctly handle more than 65535 files (issue #34)} {
        set content {}
        set count 65536
        for {set i 1} {$i <= $count} {incr i} {
            lappend content $i ""
        }

        create $content
        mount
        set fnames [glob -directory $mountdir -nocomplain -tails *]
        assert {[llength $fnames] == $count} "not all files are visible"
        umount
    }

    fstest add-file-to-empty-archive {Add file to empty archive} {
        set fname $tmpdir/empty.zip

        mount
        makeFile {file content} somefile $mountdir
        umount

        check {
            somefile {file content}
        }
    }

    fstest add-file {Add file to archive} {
        create {
            foo.bar foobar
            f/
            f/o/
            f/o/o content
            foo/
            foo/bar foo-bar
        }
        mount
        makeFile moo-moo moo $mountdir
        umount

        check {
            moo moo-moo
            foo.bar foobar
            f/
            f/o/
            f/o/o content
            foo/
            foo/bar foo-bar
        }
    }

    fstest add-dir {Add directory to archive} {
        create {
            foo.bar foobar
            f/
            f/o/
            f/o/o content
            foo/
            foo/bar foo-bar
        }
        mount
        file mkdir $mountdir/foo/first
        file mkdir $mountdir/foo/first/second
        umount

        check {
            foo.bar foobar
            f/
            f/o/
            f/o/o content
            foo/
            foo/bar foo-bar
            foo/first/
            foo/first/second/
        }
    }

    fstest add-remove-file {Add file to archive and remove it} {
        create {
            foo.bar foobar
            f/
            f/o/
            f/o/o content
            foo/
            foo/bar foo-bar
        }
        mount
        makeFile moo-moo moo $mountdir
        file delete $mountdir/moo
        umount

        check {
            foo.bar foobar
            f/
            f/o/
            f/o/o content
            foo/
            foo/bar foo-bar
        }
    }

    fstest add-truncate-file {Add file to archive and truncate it} {
        create {
            foo.bar foobar
        }
        mount
        makeFile moo-moo moo $mountdir
        ftruncate $mountdir/moo 3
        umount

        check {
            foo.bar foobar
            moo moo
        }
    }

    fstest add-truncate-remove-file {Add file to archive, truncate and remove it} {
        create {
            foo.bar foobar
        }
        mount
        makeFile moo-moo moo $mountdir
        ftruncate $mountdir/moo 3
        file delete $mountdir/moo
        umount

        check {
            foo.bar foobar
        }
    }

    fstest add-overwrite-file {Add file to archive and overwrite it} {
        create {
            foo.bar foobar
        }
        mount
        makeFile moo-moo moo $mountdir
        makeFile Gerasim moo $mountdir
        umount

        check {
            foo.bar foobar
            moo Gerasim
        }
    }

    fstest remove-file {Remove file from archive} {
        create {
            filename.ext blah-blah
            filename2.ext blah-blah
        }
        mount
        file delete $mountdir/filename.ext
        umount
        check {
            filename2.ext blah-blah
        }
    }

    fstest remove-dir {Remove directory from archive} {
        create {
            filename.ext blah-blah
            foo/
            foo/moo {}
            bar/
        }
        mount
        file delete -force $mountdir/foo
        umount
        check {
            filename.ext blah-blah
            bar/
        }
    }

    fstest remove-nonexistent-dir {Remove nonexistent directory from archive} {
        create {
            filename.ext blah-blah
            bar/
        }
        mount
        if {![ catch {
            exec rmdir $mountdir/foo
        } err opts ]} {
            error "rmdir error is expected!"
        }
        umount
        check {
            filename.ext blah-blah
            bar/
        }
    }

    fstest remove-last-file {Remove last file from archive} {
        create {
            filename.ext blah-blah
        }
        mount
        file delete $mountdir/filename.ext
        umount
        if {[ file exist $fname ]} {
            error "Archive should not exist!"
        }
    }

    fstest overwrite-file {Overwrite existing file} {
        create {
            filename.ext blah-blah
        }
        mount

        set f [ open $mountdir/filename.ext w ]
        puts $f "Be-be-be!"
        close $f
        umount
        check {
            filename.ext "Be-be-be!\n"
        }
    }

    fstest truncate {Truncate existing file} {
        create {
            filename.ext blah-blah
        }
        mount
        ftruncate $mountdir/filename.ext 5

        set f [ open $mountdir/filename.ext r ]
        set data [ read $f ]
        close $f

        if {[ string compare $data "blah-" ] != 0} {
            error "Invalid content: $data"
        }

        umount
        check {
            filename.ext blah-
        }
    }

    fstest truncate-remove {Truncate existing file and delete it} {
        create {
            filename.ext blah-blah
            other other
        }
        mount
        ftruncate $mountdir/filename.ext 5
        file delete $mountdir/filename.ext

        umount
        check {
            other other
        }
    }

    fstest truncate-on-chunk-boundary {Truncate existing file on a chunk boundary} {
        create [ list \
            filename.ext [ string repeat a 8192 ]
        ]
        mount
        ftruncate $mountdir/filename.ext 4096
        umount
        check [ list \
            filename.ext [ string repeat a 4096 ] \
        ]
    }

    fstest truncate-to-zero {Truncate existing file (to zero size)} {
        create {
            filename.ext blah-blah
        }
        mount
        ftruncate $mountdir/filename.ext 0
        umount
        check {
            filename.ext {}
        }
    }

    fstest truncate-after-end-same-chunk {Truncate existing file after the end (without new chunks creation)} {
        create {
            filename.ext blah-blah
        }
        mount
        ftruncate $mountdir/filename.ext 11

        set f [ open $mountdir/filename.ext r ]
        set data [ read $f ]
        close $f

        if {[ string compare $data "blah-blah\x00\x00" ] != 0} {
            error "Invalid content: $data"
        }

        umount
        check {
            filename.ext "blah-blah\x00\x00"
        }
    }

    fstest truncate-after-end-other-chunk {Truncate existing file after the end (with new chunk creation)} {
        create {
            filename.ext blah-blah
        }
        mount
        ftruncate $mountdir/filename.ext 5009
        set content "blah-blah[ string repeat "\x00" 5000 ]"

        set f [ open $mountdir/filename.ext r ]
        set data [ read $f ]
        close $f

        if {[ string compare $data $content ] != 0} {
            error "Invalid content: $data"
        }

        umount
        check [ list \
            filename.ext $content \
        ]
    }

    fstest truncate-expand-read {Truncate file, expand it and read} {
        create {
            filename.ext blah-blah
        }
        mount
        ftruncate $mountdir/filename.ext 4
        ftruncate $mountdir/filename.ext 9
        set content "blah[ string repeat "\x00" 5 ]"

        set f [ open $mountdir/filename.ext r ]
        set data [ read $f ]
        close $f

        if {[ string compare $data $content ] != 0} {
            error "Invalid content: $data"
        }

        umount
        check [ list \
            filename.ext $content \
        ]
    }

    fstest truncate-after-end-other-chunk-twice {Truncate existing file after the end (with new chunk creation, twice)} {
        create {
            filename.ext blah-blah
        }
        mount
        ftruncate $mountdir/filename.ext 5
        ftruncate $mountdir/filename.ext 5005

        set content "blah-[ string repeat "\x00" 5000 ]"

        set f [ open $mountdir/filename.ext r ]
        set data [ read $f ]
        close $f

        if {[ string compare $data $content ] != 0} {
            error "Invalid content: $data"
        }

        umount
        check [ list \
            filename.ext $content \
        ]
    }

    fstest sparse-file {Sparse files test} {
        set fname $tmpdir/archive.zip
        mount

        set count 8201

        set f [ open $mountdir/filename.ext w ]
        seek $f $count start
        puts -nonewline $f blah
        close $f

        set content "[ string repeat "\x00" $count ]blah"

        set f [ open $mountdir/filename.ext r ]
        set data [ read $f ]
        close $f

        if {[ string compare $content $data ] != 0} {
            error "Invalid file content: $data"
        }

        umount
        check [ list \
            filename.ext $content \
        ]
    }

    fstest sparse-file-2 {Sparse files test 2} {
        create {
            filename.ext start
        }
        mount

        set count 4096

        set f [ open $mountdir/filename.ext r+ ]
        seek $f [ expr {5+$count} ] start
        puts -nonewline $f end
        close $f

        set content "start[ string repeat "\x00" $count ]end"

        set f [ open $mountdir/filename.ext r ]
        set data [ read $f ]
        close $f

        if {[ string compare $content $data ] != 0} {
            error "Invalid file content: $data"
        }

        umount
        check [ list \
            filename.ext $content \
        ]
    }

    # Issue #50: Out of bounds write on sparse file
    fstest sparse-file-chunk-boundary {Sparse files expand on a chunk boundary} {
        set count 4096

        create [list \
            filename.ext [string repeat a $count] \
        ]
        mount

        set f [open $mountdir/filename.ext r+]
        seek $f [expr {$count + 1}] start
        puts -nonewline $f end
        close $f

        set content "[ string repeat a $count ]\x00end"

        set f [ open $mountdir/filename.ext r ]
        set data [ read $f ]
        close $f

        if {[ string compare $content $data ] != 0} {
            error "Invalid file content: $data"
        }

        umount
        check [ list \
            filename.ext $content \
        ]
    }

    fstest sparse-truncate {Truncate sparse file} {
        create {
            filename.ext {}
        }
        mount

        set count 4078

        set f [ open $mountdir/filename.ext r+ ]
        seek $f 8208 start
        puts -nonewline $f data
        flush $f
        ftruncate -fileid $f $count
        close $f

        set content "[ string repeat "\x00" $count ]"

        set f [ open $mountdir/filename.ext r ]
        set data [ read $f ]
        close $f

        if {[ string compare $content $data ] != 0} {
            error "Invalid file content: $data"
        }

        umount
        check [ list \
            filename.ext $content \
        ]
    }

    # Issue #50: Out of bounds write on sparse file
    fstest sparse-expand-chunk-boundary {Expand sparse file at chunk boundary} {
        set count 4096

        create [list \
            filename.ext [string repeat a $count] \
        ]
        mount

        set f [ open $mountdir/filename.ext r+ ]
        ftruncate -fileid $f [expr {$count + 1}]
        close $f

        set content "[ string repeat a $count ]\x00"

        set f [ open $mountdir/filename.ext r ]
        set data [ read $f ]
        close $f

        if {[ string compare $content $data ] != 0} {
            error "Invalid file content: $data"
        }

        umount
        check [ list \
            filename.ext $content \
        ]
    }

    fstest read-zero {Read zero-length file from archive} {
        create {
            filename.ext {}
        }
        mount
        set f [ open $mountdir/filename.ext r ]
        set data [ read $f ]
        close $f

        if {[ string compare $data "" ] != 0} {
            error "Invalid content: $data"
        }

        umount
    }

    fstest read-file {Read file from archive} {
        create {
            filename.ext blah-blah
        }
        mount
        set f [ open $mountdir/filename.ext r ]
        set data [ read $f ]
        close $f

        if {[ string compare $data "blah-blah" ] != 0} {
            error "Invalid content: $data"
        }

        umount
    }

    fstest read-file-two-handles {Read file from archive (two handles)} {
        set content [ string repeat "abcdef" 3000 ]
        set l [ string length $content ]
        create [ list \
            filename.ext $content \
        ]
        mount
        set f1 [ open $mountdir/filename.ext r ]
        set f2 [ open $mountdir/filename.ext r ]
        set positions {
            {0       6}
            {10      1000}
            {4097    322}
            {27      15}
            {1       1}
            {3333    11}
        }
        for {set i 0} {$i < [ llength $positions ]} {incr i} {
            lassign [ lindex $positions $i ] off size
            seek $f1 $off
            set data [ read $f1 $size ]
            set expected [ string range $content $off [ expr {$off + $size - 1} ] ]
            assert {$data eq $expected}

            lassign [ lindex $positions end-$i ] off size
            seek $f2 $off
            set data [ read $f2 $size ]
            set expected [ string range $content $off [ expr {$off + $size - 1} ] ]
            assert {$data eq $expected}
        }
        close $f1
        close $f2
        umount
    }

    fstest read-file-random-access {Read file from archive (random access)} {
        set content [ string repeat "abcdef" 3000 ]
        set l [ string length $content ]
        create [ list \
            filename.ext $content \
        ]
        mount
        set f [ open $mountdir/filename.ext r ]
        foreach {off size} {
            0       6
            10      1000
            4097    322
            27      15
            1       1
            3333    11
        } {
            seek $f $off
            set data [ read $f $size ]
            set expected [ string range $content $off [ expr {$off + $size - 1} ] ]
            assert {$data eq $expected}
        }
        close $f
        umount
    }

    fstest read-file-three-chunks {Read file from archive (3 chunks)} {
        set content [ string repeat "a" [ expr {4096*3-100} ] ]
        create [ list \
            filename.ext $content \
        ]
        mount
        set f [ open $mountdir/filename.ext r ]
        set data [ read $f ]
        close $f

        if {[ string compare $data $content ] != 0} {
            error "Invalid content: '$data'"
        }

        umount
    }

    fstest read-on-end {Read on the end of file} {
        set content [ string repeat "a" 100 ]
        create [ list \
            filename.ext $content \
        ]
        mount
        set f [ open $mountdir/filename.ext r ]
        fconfigure $f -encoding binary
        seek $f 98
        set data [ read $f 4 ]
        close $f

        if {[ string compare $data "aa" ] != 0} {
            error "Invalid content: '$data'"
        }

        umount
    }

    fstest read-after-end {Read after the end of file} {
        set content [ string repeat "b" 100 ]
        create [ list \
            filename.ext $content \
        ]
        mount
        set f [ open $mountdir/filename.ext r ]
        fconfigure $f -encoding binary
        seek $f 102
        set data [ read $f 4 ]
        close $f

        if {[ string compare $data "" ] != 0} {
            error "Invalid content: '$data'"
        }

        umount
    }

    fstest read-bad-crc {Read file from archive (bad CRC)} {
        use data/bad-crc.zip

        mount
        set res [ catch {
            set f [ open $mountdir/bash.txt r ]
            set data [ read $f ]
            close $f
        } err opts ]

        umount

        if {$res == 0 || [ lrange [ dict get $opts -errorcode ] 0 1 ] ne "POSIX EIO"} {
            error "Read error expected"
        }
    }

    fstest read-bad-crc-twice {Read file from archive (bad CRC, twice), changeset 80ad59679639} {
        use data/bad-crc.zip

        mount
        foreach step {1st 2nd} {
            set res [ catch {
                set f [ open $mountdir/bash.txt r ]
                set data [ read $f ]
                close $f
            } err opts ]
            if {$res == 0 || [ lrange [ dict get $opts -errorcode ] 0 1 ] ne "POSIX EIO"} {
                error "Read error expected on step $step"
            }
        }

        umount

    }

    fstest find {Check that find is working on a filesystem} {
        create {
            foo.bar foobar
            f/
            f/o/
            f/o/o content
            foo/
            foo/bar foo-bar
        }
        set in {
            foo.bar
            f
            f/o
            f/o/o
            foo
            foo/bar
        }
        mount
        set data {}
        set l [ string length "$mountdir/" ]
        foreach line [ split [ exec find $mountdir ] "\n" ] {
            if {[ string length $line ] > $l} {
                lappend data [ string range $line $l end ]
            }
        }
        umount

        if {[ lsort $in ] != [ lsort $data ]} {
            error "Invalid list of files returned: $data"
        }
    }

    fstest append {Append to file} {
        create {
            foo foo
        }
        mount
        set f [ open $mountdir/foo a ]
        puts -nonewline $f bar
        close $f

        umount
        check {
            foo foobar
        }
    }

    fstest compare-source-and-mountpoint {Compare source files with mountpoint content} {
        create [ list \
            foo.bar foobar  \
            f/              \
            f/o/            \
            f/o/o content   \
            foo/            \
            foo/bar foo-bar \
            bigFile [ string repeat "substances! " 9000 ] \
            zerofile {}     \
            longName_longName_longName_longName_longName_longName_longName_longName_longName_longName_longName_longName_longName_longName_longName_longName_longName_longName_longName_longName_longName_longName_longName_longName_longName {}
        ]
        mount
        exec diff -Nura $tmpdir/archiveSource $mountdir
        umount
    }

    fstest iconv-cp866 {Check that archive from 'other' OS correctly mounted} {
        use data/cp866.zip

        mount -o modules=iconv,from_code=cp866

        if {[ lsort [ glob -directory $mountdir -nocomplain -tails * ] ] ne
                [ lsort "{\u0422\u0435\u043a\u0441\u0442\u043e\u0432\u044b\u0439 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442.txt} \u0414\u0430\u0442\u0430" ]} {
            error "File names incorrectly decoded: [ glob -directory $mountdir * ]"
        }

        umount
    }

    fstest iconv-create {Archive creation with iconv module} {
        set natName "\u041B\u0435\u043D\u0438\u043D/\u041F\u0430\u0440\u0442\u0438\u044F/\u041A\u043E\u043C\u0441\u043E\u043C\u043E\u043B"
        mount -o modules=iconv,from_code=cp866
        makeFile "111" $natName $mountdir
        umount

        mount -o modules=iconv,from_code=cp866
        try {
            set f [open "$mountdir/$natName" r]
            try {
                assert {[read $f] eq "111"} "bad file content"
            } finally {
                close $f
            }
        } finally {
            umount
        }
    }

    fstest rename-file {Rename file} {
        create {
            foo.bar foobar
        }
        mount
        file rename $mountdir/foo.bar $mountdir/john_doe
        umount

        check {
            john_doe foobar
        }
    }

    fstest rename-non-ascii-file {Rename file with non-ASCII characters in name} {
        create {
            \u0431\u0430\u043B\u0430\u043B\u0430\u0439\u043A\u0430 foobar
        }
        mount
        file rename $mountdir/\u0431\u0430\u043B\u0430\u043B\u0430\u0439\u043A\u0430 $mountdir/\u043C\u0435\u0434\u0432\u0435\u0434\u044C
        umount

        check {
            \u043C\u0435\u0434\u0432\u0435\u0434\u044C foobar
        }
    }

    fstest rename-file-new-dir {Rename file (new directory creation)} {
        create {
            foo.bar foobar
            squirrel belka
        }
        mount
        file mkdir $mountdir/test
        file rename $mountdir/foo.bar $mountdir/test/john_doe
        set ls [ glob -directory $mountdir -tails * ]
        if {![ ::struct::set equal {test squirrel} $ls ]} {
            error "Invalid files in /: $ls"
        }
        set ls [ glob -directory $mountdir/test -tails * ]
        if {![ ::struct::set equal {john_doe} $ls ]} {
            error "Invalid files in /test: $ls"
        }
        umount

        check {
            test/john_doe foobar
            squirrel belka
        }
    }

    fstest rename-file-new-path {Rename file (change directory)} {
        create {
            foo.bar foobar
            test/
            test/blah {blah-blah}
        }
        mount
        file rename $mountdir/foo.bar $mountdir/test/john_doe
        set ls [ glob -directory $mountdir -tails * ]
        if {![ ::struct::set equal {test} $ls ]} {
            error "Invalid files in /: $ls"
        }
        set ls [ glob -directory $mountdir/test -tails * ]
        if {![ ::struct::set equal {blah john_doe} $ls ]} {
            error "Invalid files in /test: $ls"
        }
        umount

        check {
            test/john_doe foobar
            test/blah {blah-blah}
        }
    }

    fstest rename-empty-dir {Rename empty directory} {
        create {
            foo/
        }
        mount
        file rename $mountdir/foo $mountdir/bar
        umount

        check {
            bar/
        }
    }

    fstest rename-non-empty-dir {Rename non-empty directory} {
        create {
            foo/john/doe {Hi}
            foo/bar {content}
            foo/duck/tape/1 1
        }
        mount
        file rename $mountdir/foo $mountdir/bar
        umount

        check {
            bar/john/doe {Hi}
            bar/bar {content}
            bar/duck/tape/1 1
        }
    }

    fstest rename-non-empty-dir-new-path {Rename non-empty directory (new dir)} {
        create {
            foo/bar {content}
            foo/john/doe {Hi}
            foo/duck/tape/
        }
        mount
        file mkdir $mountdir/bar
        file rename $mountdir/foo $mountdir/bar/duck
        umount

        check {
            bar/duck/bar {content}
            bar/duck/john/doe {Hi}
            bar/duck/duck/tape/
        }
    }

    fstest rename-file-to-existent {Renamed file to existent file} {
        create {
            kitten {Meow}
            puppy {Woof}
        }
        mount
        file rename -force $mountdir/kitten $mountdir/puppy
        umount

        check {
            puppy {Meow}
        }
    }

    fstest size-file {Check file size} {
        create {
            foobar blah-blah
        }
        mount
        assert {[ file size $mountdir/foobar ] == 9}
        makeFile doe john $mountdir
        assert {[ file size $mountdir/john ] == 3}
        umount
        check {
            foobar blah-blah
            john doe
        }
    }

    fstest size-dir {Check directory size} {
        create {
            foobar/
        }
        mount
        assert {[ file size $mountdir/foobar ] == 0}
        file mkdir $mountdir/john
        assert {[ file size $mountdir/john ] == 0}
        umount
        check {
            foobar/
            john/
        }
    }

    fstest read-only-mode {Check read only mode} {
        create {
            foo.bar foobar
        }
        file copy $fname $fname-copy
        mount -r
        umount

        exec diff $fname $fname-copy
    }

    fstest implicit-read-only-file {Check that read-only file is mounted read-only} {
        create {
            foo.bar foobar
        }
        exec chmod a-w $fname
        mount
        try {
            set f [open $mountdir/newfile w]
        } trap {POSIX EROFS} {} {
            # as expected
        } on error {err opts} {
            return -options $opts "read-only filesystem error is expected!"
        } finally {
            catch {close $f}
        }
        umount

        check {
            foo.bar foobar
        }
    }

    fstest implicit-read-only-dir {Check that file in read-only directory is mounted read-only} {
        create {
            foo.bar foobar
        }
        exec chmod a-w [file dirname $fname]
        mount
        try {
            set f [open $mountdir/newfile w]
        } trap {POSIX EROFS} {} {
            # as expected
        } on error {err opts} {
            return -options $opts "read-only filesystem error is expected!"
        } finally {
            catch {close $f}
        }
        umount

        check {
            foo.bar foobar
        }
    }

    fstest dir-stub-read-only {Check that archive is not modified after mount/unmount in case of stub directories is created while loading file tree} {
        file copy data/not-full-path.zip $tmpdir/not-full-path.zip
        set fname $tmpdir/not-full-path.zip
        mount -r
        assert {[file exists $mountdir/foo/bar]}
        umount
        exec diff $fname data/not-full-path.zip
    }

    fstest dir-stub-read-only-deep {Check that archive is not modified after mount/unmount in case of stub directories is created while loading file tree (deep path, issue #43)} {
        file copy data/issue-43.zip $tmpdir/issue-43.zip
        set fname $tmpdir/issue-43.zip
        mount -r
        exec cat $mountdir/a/b/c/d/e/f/g
        exec cat $mountdir/a/b/c/d/e/f/g2
        umount
        exec diff $fname data/issue-43.zip
    }

    fstest dir-stub-rename {Check stub dirs rename} {
        file copy data/not-full-path.zip $tmpdir/not-full-path.zip
        set fname $tmpdir/not-full-path.zip
        mount
        assert {[file exists $mountdir/foo/bar]}
        file rename $mountdir/foo $mountdir/foofoo
        umount
        check {
            bebebe bebe\n
            foofoo/
            foofoo/bar blah-blah\n
        }
    }

    fstest dir-stub-rename-deep {Check stub dirs rename (deep dir structure)} {
        file copy data/not-full-path-deep.zip $tmpdir/not-full-path.zip
        set fname $tmpdir/not-full-path.zip
        mount
        assert {[file exists $mountdir/sim/salabim/rahat/lukum]}
        file rename $mountdir/sim/salabim $mountdir/sim/sim
        assert {[file exists $mountdir/sim/sim/rahat/lukum]}
        umount
        check {
            sim/
            sim/sim/
            sim/sim/rahat/
            sim/sim/rahat/lukum AAAAAAAAAA
            sim/sim/rahat-lukum BBBBBBBBBB
        }
    }

    fstest dir-stub-rmdir {Check that stubbed dir removed successfully} {
        file copy data/not-full-path.zip $tmpdir/not-full-path.zip
        set fname $tmpdir/not-full-path.zip
        mount
        file delete -force $mountdir/foo
        umount
        check {
            bebebe bebe\n
        }
    }

    fstest dir-stub-delete-files {Check that stub directory persists after content erase} {
        file copy data/not-full-path.zip $tmpdir/not-full-path.zip
        set fname $tmpdir/not-full-path.zip
        mount
        file delete $mountdir/foo/bar
        umount
        check {
            bebebe bebe\n
            foo/
        }
    }

    fstest dir-stub-chmod {Check that stub directory permissions persists} {
        file copy data/not-full-path.zip $tmpdir/not-full-path.zip
        set fname $tmpdir/not-full-path.zip
        mount
        file attributes $mountdir/foo/bar -permissions 0750
        umount

        mount
        assert {([file attributes $mountdir/foo/bar -permissions] & 0777) == 0750} "directory permissions not persist"
        umount
    }

    fstest mkdir-rmdir {Check that mkdir()-rmdir() success} {
        create {
            a b
        }

        mount
        file mkdir $mountdir/foo
        file delete $mountdir/foo
        umount

        check {
            a b
        }
    }

    fstest rmdir {Check that rmdir() success on non-stub directory} {
        create {
            a b
            foo/
        }

        mount
        file delete $mountdir/foo
        umount

        check {
            a b
        }
    }

    fstest parent-relative-paths-rw {Check for paths relative to parent directory in archive (read-write)} {
        use data/parent-relative-paths.zip
        if {![ catch {mount} err opts ] ||
                [ dict get $opts -errorcode ] ne "NOTMOUNTED"} {
            error "Mount error is expected"
        } else {
            set msg [ stripValgrindOutput [ join $error \n ] ]
            if {![ regexp {^fuse-zip: unable to open ZIP file: paths relative to parent directory are not supported} $msg ]} {
                error "Invalid error message: $msg"
            }
        }
    }

    fstest absolute-path-rw {Check for absolute paths in archive (read-write)} {
        use data/absolute-path.zip
        if {![catch {mount} err opts] || [dict get $opts -errorcode] ne "NOTMOUNTED"} {
            error "Mount error is expected"
        } else {
            set msg [stripValgrindOutput [join $error \n]]
            if {![regexp {^fuse-zip: unable to open ZIP file: absolute paths are not supported} $msg]} {
                error "Invalid error message: $msg"
            }
        }
    }

    fstest parent-relative-paths-ro {Check for paths relative to parent directory in archive (read-only)} {
        use data/parent-relative-paths.zip
        mount -r
        set actual [split [string trim [exec sh -c "cd $mountdir; find . -printf '%p '"]]]
        set expected {. ./UPUP ./UPUP/INSTALL ./UP ./UP/other ./UP/other/LICENSE}
        assert {[struct::set equal $actual $expected]} "file list is not equal"

        set f [open $mountdir/UPUP/INSTALL r]
        set data [read $f]
        close $f

        assert {[regexp {^You need the following libraries:} $data]} "invalid file content"

        umount
    }

    fstest absolute-path-ro {Check for absolute paths in archive (read-only)} {
        use data/absolute-path.zip
        mount -r
        set actual [split [string trim [exec sh -c "cd $mountdir; find . -printf '%p '"]]]
        set expected {. ./ROOT ./ROOT/rootname.ext}
        assert {[struct::set equal $actual $expected]} "file list is not equal"

        set f [open $mountdir/ROOT/rootname.ext r]
        set data [read $f]
        close $f

        assert {$data eq "AAAAAAAAAAAAAAAAAAAAAA"} "invalid file content"

        umount
    }

    fstest mixed-paths-ro {Check mixed paths in archive (absolute, relative and "normal")} {
        use data/mixed-paths.zip
        mount -r
        set actual [split [string trim [exec sh -c "cd $mountdir; find . -printf '%p '"]]]
        set expected {. ./ROOT ./ROOT/root ./ROOT/root/name.ext ./CUR ./CUR/normal.file ./UP ./UP/parent ./UP/parent/relative}
        assert {[struct::set equal $actual $expected]} "file list is not equal"

        foreach {fname expected} {
            /ROOT/root/name.ext AAAAAAAAAA
            /CUR/normal.file    BBBBBBBBBB
            /UP/parent/relative CCCCCCCCCC
        } {
            set f [open $mountdir/$fname r]
            set data [read $f]
            close $f
            assert {$data eq $expected} "invalid file content for $fname: $data"
        }

        umount
    }

    fstest atime {Check that atime modified after file access} {
        create {
            foo.bar foobar
        }
        mount
        file atime $mountdir/foo.bar 0
        assert {[file atime $mountdir/foo.bar] == 0} "atime not modified"
        # first access
        set f [open $mountdir/foo.bar r]
        read $f
        close $f
        after 2000
        set atime1 [file atime $mountdir/foo.bar]
        assert {abs($atime1 - [clock seconds]) < 60} "weird atime value $atime1"
        after 2000
        # second access
        set f [open $mountdir/foo.bar r]
        read $f
        close $f
        after 2000
        set atime2 [file atime $mountdir/foo.bar]
        assert {abs($atime2 - [clock seconds]) < 60} "weird atime value $atime2"
        assert {$atime2 > $atime1} "atime1 ($atime1) should be less that atime2 ($atime2)"
        umount
    }

    fstest time-from-extra-field {Check that time correctly loaded from extra field} {
        use data/extrafld.zip
        mount -r

        set mtime [file mtime $mountdir/README]
        set atime [file atime $mountdir/README]

        assert {$mtime == 0x51CE6FD4} "mtime must be Sat, 29 Jun 2013 09:25:40 +0400"
        assert {$atime == 0x52C7E372} "atime must be Sat, 04 Jan 2014 14:33:22 +0400"

        umount
    }

    fstest time-from-ntfs-extra-field {Check that time is correctly loaded from NTFS extra field} {
        use data/ntfs-extrafld.zip
        mount -r

        lassign [getPreciseTimes $mountdir/test.txt] mtime atime

        set exp_mtime "2019-06-13 14:22:01.722114700 +0000"
        set exp_atime "2019-06-13 14:22:03.770100400 +0000"

        assert {$mtime == $exp_mtime} "mtime must be $exp_mtime but $mtime read"
        assert {$atime == $exp_atime} "atime must be $exp_atime but $atime read"

        umount
    }

    fstest time-preserve {Check that time is preserved across remounts} {
        set new_mtime 1511111111
        set new_atime 1522222222

        create {
            foo.bar foobar
        }
        mount
        set f [open $mountdir/foo.bar w]
        puts $f "meow"
        close $f
        file mtime $mountdir/foo.bar $new_mtime
        file atime $mountdir/foo.bar $new_atime
        umount

        mount
        set mtime [file mtime $mountdir/foo.bar]
        set atime [file atime $mountdir/foo.bar]
        umount

        assert {$mtime == $new_mtime} "mtime changed to $mtime ([clock format $mtime])"
        assert {$atime == $new_atime} "atime changed to $atime ([clock format $atime])"
    }

    fstest time-preserve-high-precision {Check that high-precision time is preserved across remounts} {
        set new_atime "2018-07-16 01:23:45.123456700 +0000"
        set new_mtime "2018-07-16 12:34:56.789012300 +0000"

        create {
            blah blah
        }
        mount
        set f [open $mountdir/foo.bar w]
        puts $f "meow"
        close $f
        exec touch -m -d $new_mtime $mountdir/foo.bar
        exec touch -a -d $new_atime $mountdir/foo.bar
        umount

        mount
        lassign [getPreciseTimes $mountdir/foo.bar] mtime atime
        umount

        assert {$mtime == $new_mtime} "mtime changed to $mtime"
        assert {$atime == $new_atime} "atime changed to $atime"
    }

    fstest time-preserve-high-precision-no-force {Check that high-precision time is only updated, not created} {
        set new_time_precise "2018-07-28 01:23:45.123456700 +0000"
        set new_time         "2018-07-28 01:23:45.000000000 +0000"

        use data/with-and-without-precise-time.zip

        mount
        exec touch -d $new_time_precise $mountdir/with-precise
        exec touch -d $new_time_precise $mountdir/without-precise
        umount

        mount -r
        lassign [getPreciseTimes $mountdir/with-precise] mtime1
        lassign [getPreciseTimes $mountdir/without-precise] mtime2
        umount

        assert {$mtime1 == $new_time_precise} "precise time not updated (time is $mtime1)"
        assert {$mtime2 == $new_time} "precise time unexpectedly created (time is $mtime2)"
    }

    fstest time-preserve-high-precision-force {Check that high-precision time is created if force flag is given} {
        set new_time_precise "2018-07-28 01:23:45.123456700 +0000"
        set new_time         "2018-07-28 01:23:45.000000000 +0000"
        set unmodified_time  "2019-07-28 15:24:25.000000000 +0000"

        use data/with-and-without-precise-time.zip

        mount -o force_precise_time
        exec touch -d $new_time_precise $mountdir/with-precise
        exec touch -d $new_time_precise $mountdir/without-precise
        umount

        mount -r
        lassign [getPreciseTimes $mountdir/with-precise] mtime1
        lassign [getPreciseTimes $mountdir/without-precise] mtime2
        lassign [getPreciseTimes $mountdir/unmodified] mtime3
        umount

        assert {$mtime1 == $new_time_precise} "precise time not updated (time is $mtime1)"
        assert {$mtime2 == $new_time_precise} "precise time not created (time is $mtime2)"
        assert {$mtime3 == $unmodified_time} "precise time id not created (time is $mtime3)"
    }

    fstest atime-mtime-modification {Check atime and mtime modification cases} {
        create {
            pet cat
        }
        set name $mountdir/pet
        mount
        set f [open $name w]
        puts $f dog
        close $f
        file stat $name stat1
        after 2000
        set f [open $name r]
        read $f
        close $f
        file stat $name stat2
        umount

        assert {$stat1(mtime) == $stat2(mtime)} "mtime changed"
        assert {$stat2(atime) > $stat1(atime)} "atime not changed"
        assert {$stat1(ctime) == $stat2(ctime)} "ctime changed"
    }

    fstest dir-ctime {Check ctime change on link count modification} {
        create {
            dir/
        }
        mount
        file stat $mountdir/dir stat1
        after 2000
        makeFile {cat} pet $mountdir/dir
        file stat $mountdir/dir stat2
        umount
        assert {$stat1(ctime) < $stat2(ctime)} "ctime not changed"
    }

    fstest ctime-update-on-rename {Check that ctime is updated on rename} {
        use data/foobar.zip
        mount
        file stat $mountdir/foo stat1
        file rename $mountdir/foo $mountdir/foo2
        file stat $mountdir/foo2 stat2
        umount

        assert {$stat1(mtime) == $stat2(mtime)} "mtime changed"
        assert {$stat1(atime) == $stat2(atime)} "atime changed"
        assert {$stat1(ctime) <  $stat2(ctime)} "ctime not updated"
    }

    fstest dir-accessible-after-creation {Check that directory is accessible after creation} {
        create {
            file content
        }
        mount
        file mkdir $mountdir/dir
        assert {[file isdirectory $mountdir/dir]} "dir is not a directory"
        file mkdir $mountdir/dir/subdir
        assert {[file isdirectory $mountdir/dir/subdir]} "dir/subdir is not a directory"
        umount
    }

    fstest file-accessible-after-creation {Check that file is readable after creation} {
        create {
            cat meow
        }
        mount
        set f [open $mountdir/dog w]
        puts $f woof
        close $f
        assert {[file isfile $mountdir/dog]} "file is not regular"
        set f [open $mountdir/dog r]
        read $f
        close $f
        umount
    }

    fstest dos-permissions {Check DOS file permissions handling} {
        use data/dos-perm.zip
        mount -r
        assert {[file isdirectory $mountdir/dir]} "not a directory"
        foreach name {hidden readonly normal} {
            assert {[file isfile $mountdir/dir/$name.txt]} "file 'dir/$name.txt' is not regular"
            if {$name eq "readonly"} {
                assert {[file attributes $mountdir/dir/$name.txt -permissions] == 0444} "file 'dir/$name.txt' is writable"
            } else {
                assert {[file attributes $mountdir/dir/$name.txt -permissions] == 0664} "file 'dir/$name.txt' is not writable"
            }
        }
        umount
    }

    fstest unix-permissions {Check UNIX file permissions handling} {
        use data/unix-perm.zip
        mount -r
        foreach name {640 642 666 6775 777} {
            assert {[file isfile $mountdir/$name]} "file 'dir/$name.txt' is not regular"
            assert {[file attributes $mountdir/$name -permissions] == "0$name"} "file '$name' is has wrong permissions"
        }
        umount
    }

    fstest check-zip-permissions {Check permissions in output ZIP archive} {
        mount
        makeFile ABC regular  $mountdir
        makeFile DEF readonly $mountdir
        file attributes $mountdir/readonly -permissions ug=r,o=
        makeFile GHI .hidden  $mountdir
        makeFile JKL altered  $mountdir
        file attributes $mountdir/altered -permissions 01234
        file mkdir $mountdir/dir
        umount

        set regular  [getZipItemInfo $fname regular]
        set readonly [getZipItemInfo $fname readonly]
        set hidden   [getZipItemInfo $fname .hidden]
        set altered  [getZipItemInfo $fname altered]
        set dir      [getZipItemInfo $fname dir/]

        eassert [dict get $regular  unix_perms] eq 100664 "regular file UNIX permissions"
        eassert [dict get $regular  dos_perms]  eq 00     "regular file DOS permissions"

        eassert [dict get $readonly unix_perms] eq 100440 "read-only file UNIX permissions"
        eassert [dict get $readonly dos_perms]  eq 01     "read-only file DOS permissions"

        eassert [dict get $hidden   unix_perms] eq 100664 "hidden file UNIX permissions"
        eassert [dict get $hidden   dos_perms]  eq 02     "hidden file DOS permissions"

        eassert [dict get $altered  unix_perms] eq 101234 "altered file UNIX permissions"
        eassert [dict get $altered  dos_perms]  eq 00     "altered file DOS permissions"

        eassert [dict get $dir      unix_perms] eq 040775 "directory UNIX permissions"
        eassert [dict get $dir      dos_perms]  eq 10     "directory DOS permissions"
    }

    fstest chmod-file {Check chmod() for file} {
        create {
            cat meow
        }
        mount
        set n $mountdir/cat
        set f [open $n w]
        puts $f purr
        close $f
        file attributes $n -permissions 0666
        assert {[file attributes $n -permissions] == 0666} "should be a=rw"
        file attributes $n -permissions 0444
        assert {[file attributes $n -permissions] == 0444} "should be a=r"
        umount

        set info [getZipItemInfo $fname cat]
        eassert [dict get $info unix_perms] eq 100444 "bad UNIX permissions"
        eassert [dict get $info dos_perms]  eq 01     "bad DOS permissions"

        mount
        assert {[file attributes $n -permissions] == 0444} "permissions not persist"
        umount
    }

    fstest chmod-file-not-modified {Check chmod() for not modified file} {
        create {
            cat meow
        }
        mount
        set n $mountdir/cat
        file attributes $n -permissions 0666
        assert {[file attributes $n -permissions] == 0666} "should be a=rw"
        file attributes $n -permissions 0444
        assert {[file attributes $n -permissions] == 0444} "should be a=r"
        umount

        set info [getZipItemInfo $fname cat]
        eassert [dict get $info unix_perms] eq 100444 "bad UNIX permissions"
        eassert [dict get $info dos_perms]  eq 01     "bad DOS permissions"

        mount
        assert {[file attributes $n -permissions] == 0444} "permissions not persist"
        umount
    }

    fstest chmod-dir {Check chmod() for directory} {
        create {
            cat/
        }
        mount
        set n $mountdir/cat
        file attributes $n -permissions 0777
        assert {([file attributes $n -permissions] & 0777) == 0777} "should be a=rwx"
        file attributes $n -permissions 0555
        assert {([file attributes $n -permissions] & 0777) == 0555} "should be a=rx"
        umount

        set info [getZipItemInfo $fname cat/]
        eassert [dict get $info unix_perms] eq 040555 "bad UNIX permissions"
        eassert [dict get $info dos_perms]  eq 11     "bad DOS permissions"

        mount
        assert {([file attributes $n -permissions] & 0777) == 0555} "permissions not persist"
        umount
    }

    fstest symlink-infozip {Check symlink in Info-ZIP format} {
        use data/symlink.zip
        mount -r
        assert {[file type $mountdir/symlink] eq "link"}
        assert {[file readlink $mountdir/symlink] eq "../tmp/date"} "invalid link content"
        umount
    }

    fstest symlink-pkware {Check symlink in PKWARE format} {
        use data/pkware-specials.zip
        mount -r
        assert {[file type $mountdir/symlink2] eq "link"}
        assert {[file readlink $mountdir/symlink2] eq "regular"} "invalid link content"
        umount
    }

    fstest symlink-pkware-hardlinked {Check symlink in PKWARE format (hardlinked symlink)} {
        use data/pkware-specials.zip
        mount -r
        assert {[file type $mountdir/symlink] eq "link"}
        assert {[file readlink $mountdir/symlink] eq "regular"} "invalid link content"
        umount
    }

    fstest symlink {Check symlink} {
        create {
            foo bar
        }
        mount
        file link -symbolic $mountdir/symlink /dev/null
        assert {[file readlink $mountdir/symlink] eq "/dev/null"} "invalid link content"
        umount

        set info [getZipItemInfo $fname symlink]
        eassert [dict get $info unix_perms] eq 120777 "bad UNIX permissions"
        eassert [dict get $info dos_perms]  eq 00     "bad DOS permissions"

        mount
        assert {[file readlink $mountdir/symlink] eq "/dev/null"} "invalid link content after umount"
        umount
    }

    fstest symlink-pkware-touch {Check PKWARE format symlink metadata update and save} {
        use data/pkware-symlink.zip
        mount
        exec touch -h -a -t 201908091406 $mountdir/symlink
        umount

        unzip

        assert {[file type $tmpdir/extract/symlink] eq "link"}
        assert {[file readlink $tmpdir/extract/symlink] eq "regular"} "invalid link content"
    }

    fstest no-owner-info {Check that default owner:group is root:root} {
        use data/no-owner-info.zip
        mount -r
        file stat $mountdir/README stat
        assert {$stat(uid) == 0} "owner is not root"
        assert {$stat(gid) == 0} "group is not root"
        umount
    }

    fstest chown {Check chown()} {
        file copy data/no-owner-info.zip $tmpdir/new.zip
        set fname $tmpdir/new.zip

        mount
        set n $mountdir/README
        set uid [id effective userid]
        set gid [id effective groupid]
        file attributes $n -owner $uid -group $gid
        file stat $n stat
        assert {$stat(uid) == $uid} "owner is not me"
        assert {$stat(gid) == $gid} "group is not mine"
        umount

        mount
        file stat $n stat
        assert {$stat(uid) == $uid} "owner not persist after remount"
        assert {$stat(gid) == $gid} "group not persist after remount"
        file attributes $n -owner 0 -group 0
        file stat $n stat
        assert {$stat(uid) == 0} "owner is not root"
        assert {$stat(gid) == 0} "group is not root"
        umount
    }

    fstest new-file-owner {Check owner of new file} {
        create {
            foo bar
        }
        mount
        set f [open $mountdir/cat w]
        puts $f meow
        close $f

        set uid [id effective userid]
        set gid [id effective groupid]
        file stat $mountdir/cat stat
        assert {$stat(uid) == $uid} "owner is not me"
        assert {$stat(gid) == $gid} "group is not mine"
        umount
    }

    fstest file-dir-same-name {Check that archive that contain file and intermediate dir with the same name recognised as broken} {
        use data/file-dir-same-name.zip
        if {![catch {mount -r} err opts] ||
                [ dict get $opts -errorcode ] ne "NOTMOUNTED"} {
            error "Mount error is expected"
        } else {
            set msg [stripValgrindOutput [join $error \n]]
            if {![regexp {^fuse-zip: unable to open ZIP file: bad archive structure} $msg]} {
                error "Invalid error message: $msg"
            }
        }
    }

    fstest ls-after-remove-file {list directory content after file removal} {
        create {
            filename.ext blah-blah
            filename2.ext blah-blah
        }
        mount
        file delete $mountdir/filename.ext
        set fnames [glob -directory $mountdir -nocomplain -tails *]
        assert {[llength $fnames] == 1} "one file expected"
        assert {[lindex $fnames 0] eq "filename2.ext"} "one file expected"
        umount
        check {
            filename2.ext blah-blah
        }
    }

    fstest ls-after-rename-file {list directory content after file rename} {
        create {
            filename.ext blah-blah
        }
        mount
        file rename $mountdir/filename.ext $mountdir/filename2.ext
        set fnames [glob -directory $mountdir -nocomplain -tails *]
        assert {[llength $fnames] == 1} "one file expected"
        assert {[lindex $fnames 0] eq "filename2.ext"} "one file expected"
        umount
        check {
            filename2.ext blah-blah
        }
    }

    fstest subdir-module {check for subdir module support} {
        create {
            dir/
            dir/file content
        }
        mount -r -o modules=subdir,subdir=/dir/
        set f [open $mountdir/file r]
        set data [read $f]
        close $f
        assert {$data eq "content"}
        umount
    }

    fstest inode {different files must have different inode numbers} {
        create {
            foo bar
            moo woof
        }
        mount -o use_ino

        makeFile deer bee $mountdir
        makeFile elks see $mountdir

        file stat $mountdir/foo stat1
        file stat $mountdir/moo stat2
        file stat $mountdir/bee stat3
        file stat $mountdir/see stat4

        umount

        assert {$stat1(ino) != $stat2(ino)} "existing file inodes must be different"
        assert {$stat3(ino) != $stat4(ino)} "new file inodes must be different"
        assert {$stat1(ino) != $stat3(ino)} "all inodes must be different, 1"
        assert {$stat1(ino) != $stat4(ino)} "all inodes must be different, 2"
        assert {$stat2(ino) != $stat3(ino)} "all inodes must be different, 3"
        assert {$stat2(ino) != $stat4(ino)} "all inodes must be different, 4"

        eassert $stat1(nlink) == 1 "must be 1 link for non-hardlinked file"
        eassert $stat2(nlink) == 1 "must be 1 link for non-hardlinked file"
    }

    fstest comment-read-ascii {read archive and file ASCII comments} {
        use data/comment.zip
        mount -r

        set attr [getExtendedAttributes $mountdir]
        assert {[dict keys $attr] == "user.comment"}
        assert {[dict get $attr "user.comment"] == "archive comment"}

        set attr [getExtendedAttributes $mountdir/dir]
        assert {[dict keys $attr] == "user.comment"}
        assert {[dict get $attr "user.comment"] == "directory comment"}

        set attr [getExtendedAttributes $mountdir/dir/with_comment.txt]
        assert {[dict keys $attr] == "user.comment"}
        assert {[dict get $attr "user.comment"] == "file comment"}

        set attr [getExtendedAttributes $mountdir/dir/empty_comment.txt]
        assert {[dict keys $attr] == ""}

        set attr [getExtendedAttributes $mountdir/dir/without_comment.txt]
        assert {[dict keys $attr] == ""}

        umount
    }

    fstest comment-read-utf8 {read archive and file UTF-8 comments} {
        use data/comment-utf8.zip
        mount -r

        set attr [getExtendedAttributes $mountdir]
        assert {[dict keys $attr] == "user.comment"}
        assert {[dict get $attr "user.comment"] == "\u043A\u043E\u043C\u043C\u0435\u043D\u0442\u0430\u0440\u0438\u0439 \u043A \u0430\u0440\u0445\u0438\u0432\u0443"}

        set attr [getExtendedAttributes $mountdir/dir]
        assert {[dict keys $attr] == "user.comment"}
        assert {[dict get $attr "user.comment"] == "\u043A\u043E\u043C\u043C\u0435\u043D\u0442\u0430\u0440\u0438\u0439 \u043A \u043A\u0430\u0442\u0430\u043B\u043E\u0433\u0443"}

        set attr [getExtendedAttributes $mountdir/dir/with_comment.txt]
        assert {[dict keys $attr] == "user.comment"}
        assert {[dict get $attr "user.comment"] == "\u043A\u043E\u043C\u043C\u0435\u043D\u0442\u0430\u0440\u0438\u0439 \u043A \u0444\u0430\u0439\u043B\u0443"}

        set attr [getExtendedAttributes $mountdir/dir/empty_comment.txt]
        assert {[dict keys $attr] == ""}

        set attr [getExtendedAttributes $mountdir/dir/without_comment.txt]
        assert {[dict keys $attr] == ""}

        umount
    }

    fstest comment-create-without-comment {create archive without comments} {
        create {
            foo bar
        }

        mount
        makeFile meow cat $mountdir
        umount

        set comm [getZipComments $fname]
        assert {[dict get $comm ""] eq ""} "unzip: bad archive comment"
        assert {[llength [dict keys $comm]] == 1} "unzip: bad file comment"
    }

    fstest comment-create-archive {create archive comment} {
        create {
            foo bar
        }
        mount
        set attr [getExtendedAttributes $mountdir]
        assert {[dict keys $attr] == ""} "bad initial attributes"
        exec setfattr -n user.comment -v "blah-blah" $mountdir
        set attr [getExtendedAttributes $mountdir]
        assert {[dict keys $attr] == "user.comment"} "after set: bad attributes list"
        assert {[dict get $attr "user.comment"] == "blah-blah"} "after set: bad comment content"
        umount

        set comm [getZipComments $fname]
        assert {[dict get $comm ""] eq "blah-blah"} "unzip: bad comment"

        mount
        set attr [getExtendedAttributes $mountdir]
        assert {[dict keys $attr] == "user.comment"} "after remount: bad attributes list"
        assert {[dict get $attr "user.comment"] == "blah-blah"} "after remount: bad comment content"
        umount
    }

    fstest comment-create-file {create file/directory comment} {
        create {
            dir/foo bar
        }

        mount

        set attr [getExtendedAttributes $mountdir/dir]
        assert {[dict keys $attr] == ""}
        exec setfattr -n user.comment -v "dir comment" $mountdir/dir
        set attr [getExtendedAttributes $mountdir/dir]
        assert {[dict keys $attr] == "user.comment"}
        assert {[dict get $attr "user.comment"] == "dir comment"}

        set attr [getExtendedAttributes $mountdir/dir/foo]
        assert {[dict keys $attr] == ""}
        exec setfattr -n user.comment -v "file comment" $mountdir/dir/foo
        set attr [getExtendedAttributes $mountdir/dir/foo]
        assert {[dict keys $attr] == "user.comment"}
        assert {[dict get $attr "user.comment"] == "file comment"}
        exec setfattr -n user.comment -v "file comment 2" $mountdir/dir/foo
        set attr [getExtendedAttributes $mountdir/dir/foo]
        assert {[dict keys $attr] == "user.comment"}
        assert {[dict get $attr "user.comment"] == "file comment 2"}

        makeFile "meow" new $mountdir
        set attr [getExtendedAttributes $mountdir/new]
        assert {[dict keys $attr] == ""}
        exec setfattr -n user.comment -v "new comment" $mountdir/new
        set attr [getExtendedAttributes $mountdir/new]
        assert {[dict keys $attr] == "user.comment"}
        assert {[dict get $attr "user.comment"] == "new comment"}

        umount

        set comm [getZipComments $fname]
        assert {[dict get $comm ""] eq ""} "unzip: bad archive comment"
        assert {[dict get $comm "dir/"] eq "dir comment"} "unzip: bad dir comment"
        assert {[dict get $comm "dir/foo"] eq "file comment 2"} "unzip: bad dir/foo comment"

        mount

        set attr [getExtendedAttributes $mountdir/dir]
        assert {[dict keys $attr] == "user.comment"}
        assert {[dict get $attr "user.comment"] == "dir comment"}

        set attr [getExtendedAttributes $mountdir/dir/foo]
        assert {[dict keys $attr] == "user.comment"}
        assert {[dict get $attr "user.comment"] == "file comment 2"}

        set attr [getExtendedAttributes $mountdir/new]
        assert {[dict keys $attr] == "user.comment"}
        assert {[dict get $attr "user.comment"] == "new comment"}

        umount
    }

    fstest comment-create-archive-utf8 {create archive comment (UTF-8)} {
        create {
            foo bar
        }
        set comment "\u043A\u043E\u043B\u0431\u0430\u0441\u0430"

        mount
        set attr [getExtendedAttributes $mountdir]
        assert {[dict keys $attr] == ""} "bad initial attributes"
        exec setfattr -n user.comment -v $comment $mountdir
        set attr [getExtendedAttributes $mountdir]
        assert {[dict keys $attr] == "user.comment"} "after set: bad attributes list"
        assert {[dict get $attr "user.comment"] == $comment} "after set: bad comment content"
        umount

        set comm [getZipComments $fname]
        assert {[dict get $comm ""] eq $comment} "unzip: bad comment"

        mount
        set attr [getExtendedAttributes $mountdir]
        assert {[dict keys $attr] == "user.comment"} "after remount: bad attributes list"
        assert {[dict get $attr "user.comment"] == $comment} "after remount: bad comment content"
        umount
    }

    fstest comment-create-file-utf8 {create file comment (UTF-8)} {
        create {
            foo bar
        }
        set comment "\u043A\u043E\u043B\u0431\u0430\u0441\u0430"

        mount
        set attr [getExtendedAttributes $mountdir/foo]
        assert {[dict keys $attr] == ""} "bad initial attributes"
        exec setfattr -n user.comment -v $comment $mountdir/foo
        set attr [getExtendedAttributes $mountdir/foo]
        assert {[dict keys $attr] == "user.comment"} "after set: bad attributes list"
        assert {[dict get $attr "user.comment"] == $comment} "after set: bad comment content"
        umount

        set comm [getZipComments $fname]
        assert {[dict get $comm ""] eq ""} "unzip: bad archive comment"
        assert {[dict get $comm "foo"] eq $comment} "unzip: bad file comment"

        mount
        set attr [getExtendedAttributes $mountdir/foo]
        assert {[dict keys $attr] == "user.comment"} "after remount: bad attributes list"
        assert {[dict get $attr "user.comment"] == $comment} "after remount: bad comment content"
        umount
    }

    fstest comment-create-max-length {maximum-length comment} {
        set comment [string repeat A 65535]
        set dump "# file: $mountdir/foo\nuser.comment=\"$comment\""

        create {
            foo bar
        }
        mount
        exec setfattr --restore - << $dump
        umount

        set comm [getZipComments $fname]
        assert {[dict get $comm ""] eq ""} "unzip: bad archive comment"
        assert {[dict get $comm "foo"] eq $comment} "unzip: bad file comment"

        mount
        set attr [getExtendedAttributes $mountdir/foo]
        assert {[dict keys $attr] == "user.comment"}
        assert {[dict get $attr "user.comment"] == $comment}
        umount
    }

    fstest comment-create-too-long {try to create too long comment} {
        set dump "# file: $mountdir/foo\nuser.comment=\"[string repeat A 65536]\""

        create {
            foo bar
        }
        mount
        if {[catch {exec /usr/bin/env LC_ALL=C setfattr --restore - << $dump} err]} {
            assert {[regexp {^setfattr: .*: No space left on device$} $err]} "bad error text: $err"
        } else {
            error "'No space left on device' error is expected"
        }
        umount
    }

    fstest comment-create-remove-file {create comment and remove a file} {
        create {
            foo bar
        }

        mount

        makeFile "meow" new $mountdir
        set attr [getExtendedAttributes $mountdir/new]
        assert {[dict keys $attr] == ""}
        exec setfattr -n user.comment -v "new comment" $mountdir/new
        set attr [getExtendedAttributes $mountdir/new]
        assert {[dict keys $attr] == "user.comment"}
        assert {[dict get $attr "user.comment"] == "new comment"}

        file delete $mountdir/new

        umount
    }

    fstest comment-remove-archive {remove archive comment} {
        create {
            foo bar
        }

        mount

        exec setfattr -n user.comment -v "archive comment" $mountdir
        set attr [getExtendedAttributes $mountdir]
        assert {[dict keys $attr] == "user.comment"} "comment not listed"
        assert {[dict get $attr "user.comment"] == "archive comment"} "invalid comment set"

        exec setfattr -x user.comment $mountdir
        set attr [getExtendedAttributes $mountdir]
        assert {[dict keys $attr] == ""} "comment not removed"

        exec setfattr -n user.comment -v "archive comment 2" $mountdir
        set attr [getExtendedAttributes $mountdir]
        assert {[dict keys $attr] == "user.comment"} "comment not listed after reset"
        assert {[dict get $attr "user.comment"] == "archive comment 2"} "invalid comment re-set"

        umount

        set comm [getZipComments $fname]
        assert {[dict get $comm ""] eq "archive comment 2"} "unzip: comment not set"

        mount

        set attr [getExtendedAttributes $mountdir]
        assert {[dict keys $attr] == "user.comment"} "comment not listed after remount"
        assert {[dict get $attr "user.comment"] == "archive comment 2"} "invalid comment re-read"

        exec setfattr -x user.comment $mountdir
        set attr [getExtendedAttributes $mountdir]
        assert {[dict keys $attr] == ""} "comment not removed secondary"

        umount

        set comm [getZipComments $fname]
        assert {[dict get $comm ""] eq ""} "unzip: comment not removed"
    }

    fstest comment-remove-file {remove file comment} {
        create {
            foo bar
        }

        mount

        exec setfattr -n user.comment -v "file comment" $mountdir/foo
        set attr [getExtendedAttributes $mountdir/foo]
        assert {[dict keys $attr] == "user.comment"} "comment not listed"
        assert {[dict get $attr "user.comment"] == "file comment"} "invalid comment set"

        exec setfattr -x user.comment $mountdir/foo
        set attr [getExtendedAttributes $mountdir/foo]
        assert {[dict keys $attr] == ""} "comment not removed"

        exec setfattr -n user.comment -v "file comment 2" $mountdir/foo
        set attr [getExtendedAttributes $mountdir/foo]
        assert {[dict keys $attr] == "user.comment"} "comment not listed after reset"
        assert {[dict get $attr "user.comment"] == "file comment 2"} "invalid comment re-set"

        umount

        set comm [getZipComments $fname]
        assert {[dict get $comm "foo"] eq "file comment 2"} "unzip: comment not set"

        mount

        set attr [getExtendedAttributes $mountdir/foo]
        assert {[dict keys $attr] == "user.comment"} "comment not listed after remount"
        assert {[dict get $attr "user.comment"] == "file comment 2"} "invalid comment re-read"

        exec setfattr -x user.comment $mountdir/foo
        set attr [getExtendedAttributes $mountdir/foo]
        assert {[dict keys $attr] == ""} "comment not removed secondary"

        umount

        set comm [getZipComments $fname]
        assert {![dict exists $comm "foo"]} "unzip: comment not removed"
    }

    fstest special-fifo-read-infozip {read zipped FIFOs (Info-ZIP)} {
        use data/fifo.zip
        mount -r

        assert {[file type $mountdir/fifo] eq "file"}
        set f [open $mountdir/fifo r]
        set content1 [read $f]
        close $f

        assert {[file type $mountdir/-] eq "file"}
        set f [open $mountdir/- r]
        set content2 [read $f]
        close $f

        umount

        assert {$content1 eq "FIFO content\n"} "bad zipped FIFO content"
        assert {$content2 eq "stdin content\n"} "bad zipped stdin content"
    }

    fstest special-fifo-read-pkware {read zipped FIFOs (PKWARE)} {
        use data/pkware-specials.zip

        mount -r

        assert {[file type $mountdir/fifo] eq "fifo"}

        umount
    }

    fstest special-fifo-create {create and save FIFO} {
        mount

        exec mknod $mountdir/fifo p
        assert {[file type $mountdir/fifo] eq "fifo"} "bad created node type"
        umount

        set info [getZipItemInfo $fname fifo]
        eassert [dict get $info unix_perms] eq 010664 "bad UNIX permissions"
        eassert [dict get $info dos_perms]  eq 00     "bad DOS permissions"

        mount
        assert {[file type $mountdir/fifo] eq "fifo"} "reopen: bad node type"
        umount
    }

    fstest special-device-read {read device nodes from archive} {
        use data/pkware-specials.zip

        mount -r

        assert {[file type $mountdir/block] eq "blockSpecial"}
        lassign [exec stat -c "%t %T" $mountdir/block] maj min
        assert {$maj == 8 && $min == 1} "failed block device numbers $maj, $min"

        assert {[file type $mountdir/char] eq "characterSpecial"}
        lassign [exec stat -c "%t %T" $mountdir/char] maj min
        assert {$maj == 4 && $min == 0} "failed char device numbers $maj, $min"

        umount
    }

    fstest special-device-create {create and save device node} {
        mount -o allow_root

        exec sudo mknod $mountdir/block b 8 255
        assert {[file type $mountdir/block] eq "blockSpecial"}
        lassign [exec stat -c "%t %T" $mountdir/block] maj min
        assert {$maj == 8 && $min eq "ff"} "create: failed block device numbers $maj, $min"

        exec sudo mknod $mountdir/char  c 4 63
        assert {[file type $mountdir/char] eq "characterSpecial"}
        lassign [exec stat -c "%t %T" $mountdir/char] maj min
        assert {$maj == 4 && $min == "3f"} "create: failed char device numbers $maj, $min"

        umount

        set info [getZipItemInfo $fname block]
        eassert [dict get $info unix_perms] eq 060664 "bad UNIX permissions"
        eassert [dict get $info dos_perms]  eq 00     "bad DOS permissions"

        set info [getZipItemInfo $fname char]
        eassert [dict get $info unix_perms] eq 020664 "bad UNIX permissions"
        eassert [dict get $info dos_perms]  eq 00     "bad DOS permissions"

        mount

        assert {[file type $mountdir/block] eq "blockSpecial"}
        lassign [exec stat -c "%t %T" $mountdir/block] maj min
        assert {$maj == 8 && $min == "ff"} "remount: failed block device numbers $maj, $min"

        assert {[file type $mountdir/char] eq "characterSpecial"}
        lassign [exec stat -c "%t %T" $mountdir/char] maj min
        assert {$maj == 4 && $min == "3f"} "remount: failed char device numbers $maj, $min"

        umount
    } sudo

    fstest special-socket-read {read socket from archive} {
        use data/pkware-specials.zip

        mount -r

        assert {[file type $mountdir/socket] eq "socket"}

        umount
    }

    fstest special-socket-create {create and save socket} {
        mount

        set p [exec socat UNIX-LISTEN:$mountdir/socket,unlink-close=0 - &]
        after 500
        exec socat - UNIX-CONNECT:$mountdir/socket << ""
        wait $p
        assert {[file type $mountdir/socket] eq "socket"} "socket not created"

        umount

        set info [getZipItemInfo $fname socket]
        eassert [dict get $info unix_perms] eq 140775 "bad UNIX permissions"
        eassert [dict get $info dos_perms]  eq 00     "bad DOS permissions"

        mount
        assert {[file type $mountdir/socket] eq "socket"} "socket not read"
        umount
    }

    fstest pkzip-compatibility-regular {PkZip compatibility: regular file} {
        mount
        makeFile "file content" regular $mountdir
        umount

        pkzipExtract
        set f [open $tmpdir/extract/regular r]
        set data [read $f]
        close $f

        assert {$data eq "file content"} "bad extracted file content: $data"
    } pkzip

    fstest pkzip-compatibility-fifo {PkZip compatibility: FIFO} {
        mount
        exec mknod $mountdir/fifo p
        umount

        pkzipExtract
        assert {[file type $tmpdir/extract/fifo] eq "fifo"} "bad extracted node type"
    } pkzip

    fstest pkzip-compatibility-socket {PkZip compatibility: socket} {
        mount
        set p [exec socat UNIX-LISTEN:$mountdir/socket,unlink-close=0 - &]
        after 500
        exec socat - UNIX-CONNECT:$mountdir/socket << ""
        wait $p
        umount

        pkzipExtract
        assert {[file type $tmpdir/extract/socket] eq "socket"} "bad extracted node type"
    } pkzip

    fstest pkzip-compatibility-device {PkZip compatibility: device} {
        mount -o allow_root
        exec sudo mknod $mountdir/block b 8 255
        exec sudo mknod $mountdir/char  c 4 63
        makeFile "file content" regular $mountdir
        umount

        pkzipExtract sudo

        set fn $tmpdir/extract/block
        assert {[file type $fn] eq "blockSpecial"}
        lassign [exec stat -c "%t %T" $fn] maj min
        assert {$maj == 8 && $min == "ff"} "remount: failed block device numbers $maj, $min"

        set fn $tmpdir/extract/char
        assert {[file type $fn] eq "characterSpecial"}
        lassign [exec stat -c "%t %T" $fn] maj min
        assert {$maj == 4 && $min == "3f"} "remount: failed char device numbers $maj, $min"

        exec sudo rm -rf $tmpdir/extract
    } {sudo pkzip}

    fstest pkzip-compatibility-symlink {PkZip compatibility: symlink} {
        mount
        file link -symbolic $mountdir/symlink /dev/null
        umount

        pkzipExtract
        assert {[file type $tmpdir/extract/symlink] eq "link"}
        assert {[file readlink $tmpdir/extract/symlink] eq "/dev/null"} "invalid link content"
    } pkzip

    fstest pkzip-compatibility-permissions {PkZip compatibility: owner and permissions} {
        mount -o allow_root
        makeFile "file content" regular $mountdir
        exec chmod 444 $mountdir/regular
        exec sudo chown 0:0 $mountdir/regular
        umount

        pkzipExtract sudo
        lassign [exec stat -c "%a %u %g" $tmpdir/extract/regular] perm uid gid
        assert {$perm eq "444"}
        assert {$uid == 0}
        assert {$gid == 0}
    } {sudo pkzip}

    fstest pkzip-compatibility-symlink-rename {PkZip compatibility: PKWARE format symlink rename and save} {
        use data/pkware-symlink.zip
        mount
        file rename $mountdir/symlink $mountdir/symlink2
        umount

        pkzipExtract

        assert {[file type $tmpdir/extract/symlink2] eq "link"}
        assert {[file readlink $tmpdir/extract/symlink2] eq "regular"} "invalid link content"
    } pkzip

    fstest hardlink-pkzip-read {Read support hardlinks created by PkZip} {
        use data/pkware-specials.zip
        mount -r -o use_ino
        # two initially hard-linked symlinks
        assert {[file type      $mountdir/symlink]  eq "link"}
        assert {[file readlink  $mountdir/symlink]  eq "regular"} "invalid link content"
        assert {[file type      $mountdir/z-hardlink-symlink] eq "link"}
        assert {[file readlink  $mountdir/z-hardlink-symlink] eq "regular"} "invalid link content"
        # hard-linked regular files
        assert {[file type      $mountdir/regular]      eq "file"}
        assert {[file type      $mountdir/z-hardlink1]  eq "file"}
        assert {[file type      $mountdir/z-hardlink2]  eq "file"}
        file stat               $mountdir/regular     stat0
        file stat               $mountdir/z-hardlink1 stat1
        file stat               $mountdir/z-hardlink2 stat2
        umount

        assert {$stat0(ino) == $stat1(ino)} "file and 1st hardlink inodes must be the same"
        assert {$stat0(ino) == $stat2(ino)} "file and 2nd hardlink inodes must be the same"
        eassert $stat0(nlink) == 3 "must be 3 links for double-hardlinked file"
    }

    fstest hardlink-rw-mode {Check that hardlinks are supported only in read-only mode} {
        use data/pkware-specials.zip
        if {![ catch {mount} err opts ] ||
                [ dict get $opts -errorcode ] ne "NOTMOUNTED"} {
            error "Mount error is expected"
        } else {
            set msg [ stripValgrindOutput [ join $error \n ] ]
            if {![ regexp {^fuse-zip: unable to open ZIP file: hard links are supported only in read-only mode$} $msg ]} {
                error "Invalid error message: $msg"
            }
        }
    }

    fstest hardlink-before-target-read {Read support for hardlink before target} {
        # not zupported by PkZip but supported by fuse-zip :)
        use data/hlink-before-target.zip
        mount -r -o use_ino
        assert {[file type $mountdir/0hlink]   eq "file"}
        assert {[file type $mountdir/1regular] eq "file"}
        file stat          $mountdir/0hlink   stat0
        file stat          $mountdir/1regular stat1
        umount

        assert {$stat0(ino) == $stat1(ino)} "file and 1st hardlink inodes must be the same"
    }

    fstest hardlink-chain-read {Read support for hardlink chain} {
        use data/hlink-chain.zip
        mount -r -o use_ino
        assert {[file type $mountdir/0regular] eq "file"}
        assert {[file type $mountdir/hlink1]   eq "file"}
        assert {[file type $mountdir/hlink2]   eq "file"}
        file stat          $mountdir/0regular stat0
        file stat          $mountdir/hlink1   stat1
        file stat          $mountdir/hlink2   stat2
        umount

        assert {$stat0(ino) == $stat1(ino)} "file and 1st hardlink inodes must be the same"
        assert {$stat0(ino) == $stat2(ino)} "file and 2nd hardlink inodes must be the same"
        eassert $stat0(nlink) == 3 "must be 3 links for double-hardlinked file"
    }

    fstest hardlink-dir-read {Read support for directory hardlink} {
        use data/hlink-dir.zip
        mount -r -o use_ino
        eassert [file type $mountdir/dir]   eq "directory" "bad dir type"
        eassert [file type $mountdir/hlink] eq "directory" "bad link type"
        umount
    }

    fstest hardlink-recursive-one {Hardlink to self} {
        use data/hlink-recursive-one.zip
        mount -r -o use_ino
        assert {![file exists $mountdir/hlink]}
        umount
    }

    fstest hardlink-recursive-two {Recursive hardlink chain} {
        use data/hlink-recursive-two.zip
        mount -r -o use_ino
        assert {![file exists $mountdir/hlink1]}
        assert {![file exists $mountdir/hlink2]}
        umount
    }

    fstest hardlink-without-target {Hardlink without a target} {
        use data/hlink-without-target.zip
        mount -r -o use_ino
        assert {![file exists $mountdir/hlink1]}
        umount
    }

    fstest hardlink-special-read {Hardlinks to special files} {
        use data/hlink-special.zip
        mount -r -o use_ino

        set file1 0block
        set file2 hlink-block
        set type blockSpecial
        eassert [file type $mountdir/$file1] eq $type
        eassert [file type $mountdir/$file2] eq $type
        lassign [exec stat -c "%t %T" $mountdir/$file1] maj min
        assert {$maj == 8 && $min == "ff"} "$file1: failed block device numbers $maj, $min"
        lassign [exec stat -c "%t %T" $mountdir/$file2] maj min
        assert {$maj == 8 && $min == "ff"} "$file2: failed block device numbers $maj, $min"

        set file1 0fifo
        set file2 hlink-fifo
        set type fifo
        eassert [file type $mountdir/$file1] eq $type
        eassert [file type $mountdir/$file2] eq $type
        file stat          $mountdir/$file1 stat1
        file stat          $mountdir/$file2 stat2
        assert {$stat1(ino) == $stat2(ino)} "$file1 and $file2 inodes must be the same"

        set file1 0socket
        set file2 hlink-socket
        set type socket
        eassert [file type $mountdir/$file1] eq $type
        eassert [file type $mountdir/$file2] eq $type
        file stat          $mountdir/$file1 stat1
        file stat          $mountdir/$file2 stat2
        assert {$stat1(ino) == $stat2(ino)} "$file1 and $file2 inodes must be the same"

        umount
    }

    fstest hardlink-symlink-read {Hardlink to symlink} {
        use data/hlink-symlink.zip
        mount -r -o use_ino

        eassert [file type $mountdir/0regular] eq file "bad regular file type"

        eassert [file type $mountdir/1symlink] eq "link" "bad symlink type"
        eassert [file readlink $mountdir/1symlink] eq "0regular" "invalid symlink content"
        file stat $mountdir/1symlink stat1

        eassert [file type $mountdir/hlink] eq "link" "bad hardlink-symlink type"
        eassert [file readlink $mountdir/hlink] eq "0regular" "invalid hlink-symlink content"
        file stat $mountdir/hlink stat2

        umount

        assert {$stat1(ino) == $stat2(ino)} "symlink inodes must be the same"
    }

    fstest hardlink-relative-read {Hardlink with relative path} {
        use data/hlink-relative.zip
        mount -r -o use_ino
        assert {[file type $mountdir/UP/0regular] eq "file"}
        assert {[file type $mountdir/UP/hlink]    eq "file"}
        file stat          $mountdir/UP/0regular stat0
        file stat          $mountdir/UP/hlink    stat1
        umount

        assert {$stat0(ino) == $stat1(ino)} "file and 1st hardlink inodes must be the same"
    }

    fstest treat-empty-type-as-regular-file {Treat files with empty type as regular (issue #67)} {
        file copy data/issue-67-empty-file-type.zip $tmpdir/issue-67.zip
        set fname $tmpdir/issue-67.zip
        mount -r
        eassert [file type $mountdir/Hi.txt] eq "file"
        set f [open $mountdir/Hi.txt r]
        set data [read $f]
        close $f
        eassert $data eq "Hi there!\n"
        umount
    }

    fstest dir-nlink {Check st_nlink for directories} {
        create {
            no-subdir/1 1
            1-subdir/subdir/2 2
            2-subdirs/subdir1/3 3
            2-subdirs/subdir2/4 4
        }
        mount

        file stat $mountdir/no-subdir stat
        eassert $stat(nlink) == 2 "must be 2 links for 0 subdirs"
        file stat $mountdir/1-subdir stat
        eassert $stat(nlink) == 3 "must be 3 links for 1 subdir"
        file stat $mountdir/2-subdirs stat
        eassert $stat(nlink) == 4 "must be 4 links for 2 subdirs"

        file mkdir $mountdir/no-subdir/new-subdir
        file stat $mountdir/no-subdir stat
        eassert $stat(nlink) == 3 "must be 3 links for 1 subdir (after creation)"

        file delete -force $mountdir/1-subdir/subdir
        file stat $mountdir/1-subdir stat
        eassert $stat(nlink) == 2 "must be 2 links for 0 subdirs (after removal)"

        umount
    }

    finalize
}
namespace delete ::fusezip::test

# vim: set ft=tcl:
